// Code generated by @vegaprotocol/jsonrpc-generator@0.0.1. DO NOT EDIT.
import { nanoid } from 'nanoid'

export namespace WalletModel {
  /**
   * A unique connection token randomly generated for each new connection. It's used to access the protected methods.
   */
  export type Token = string
  /**
   * The different access modes a permission can have.
   */
  export type AccessMode = 'read' | 'none'
  /**
   * The Vega public key to use.
   */
  export type PublicKey = string
  /**
   * The chosen mode to send the transaction:
   * - `TYPE_SYNC` returns the result of running the transaction.
   * - `TYPE_ASYNC` returns right away without waiting to hear if the transaction is even valid.
   * - `TYPE_COMMIT` waits until the transaction is committed in a block or until some timeout is reached or returns return right away if the transaction is not valid.
   */
  export type SendingMode = 'TYPE_SYNC' | 'TYPE_ASYNC' | 'TYPE_COMMIT'

  export interface Methods {
    ClientConnectWalletResult?: ClientConnectWalletResult
    ClientConnectWalletParams?: ClientConnectWalletParams
    ClientDisconnectWalletResult?: ClientDisconnectWalletResult
    ClientDisconnectWalletParams?: ClientDisconnectWalletParams
    ClientGetPermissionsResult?: ClientGetPermissionsResult
    ClientGetPermissionsParams?: ClientGetPermissionsParams
    ClientRequestPermissionsResult?: ClientRequestPermissionsResult
    ClientRequestPermissionsParams?: ClientRequestPermissionsParams
    ClientListKeysResult?: ClientListKeysResult
    ClientListKeysParams?: ClientListKeysParams
    ClientSignTransactionResult?: ClientSignTransactionResult
    ClientSignTransactionParams?: ClientSignTransactionParams
    ClientSendTransactionResult?: ClientSendTransactionResult
    ClientSendTransactionParams?: ClientSendTransactionParams
    ClientGetChainIdResult?: ClientGetChainIdResult
    ClientGetChainIdParams?: ClientGetChainIdParams
  }
  export interface ClientConnectWalletResult {
    token: Token
  }
  export interface ClientConnectWalletParams {}
  export interface ClientDisconnectWalletResult {
    [k: string]: unknown
  }
  export interface ClientDisconnectWalletParams {
    token: Token
  }
  export interface ClientGetPermissionsResult {
    permissions: PermissionsSummary
  }
  /**
   * The description of the permissions a third-party application has.
   */
  export interface PermissionsSummary {
    public_keys: AccessMode
  }
  export interface ClientGetPermissionsParams {
    token: Token
  }
  export interface ClientRequestPermissionsResult {
    permissions: PermissionsSummary
  }
  export interface ClientRequestPermissionsParams {
    token: Token
    requestedPermissions: PermissionsSummary
  }
  export interface ClientListKeysResult {
    keys: NamedPublicKey[]
  }
  /**
   * The public key with its name.
   */
  export interface NamedPublicKey {
    name: string
    publicKey: string
  }
  export interface ClientListKeysParams {
    token: Token
  }
  export interface ClientSignTransactionResult {
    transaction: SignedTransaction
  }
  /**
   * A transaction that has been signed by the wallet.
   */
  export interface SignedTransaction {
    inputData: string
    signature: {
      value: string
      algo: string
      version: number
    }
    from: {
      publicKey?: string
      address?: string
    }
    version: number
    pow: {
      tid: string
      nonce: number
    }
  }
  export interface ClientSignTransactionParams {
    token: Token
    publicKey: PublicKey
    transaction: Transaction
  }
  /**
   * The transaction as a JSON object
   */
  export interface Transaction {}
  export interface ClientSendTransactionResult {
    /**
     * The date when the API received the request to send the transaction.
     *
     * The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
     */
    receivedAt: string
    /**
     * The date when the transaction has been sent to the network.
     *
     * The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
     */
    sentAt: string
    /**
     * The hash of the transaction. It's used to uniquely identify the transaction and can be used in the block explorer to retrieve it.
     */
    transactionHash: string
    transaction: SignedTransaction
  }
  export interface ClientSendTransactionParams {
    token: Token
    publicKey: PublicKey
    sendingMode: SendingMode
    transaction: Transaction
  }
  export interface ClientGetChainIdResult {
    /**
     * The chain identifier
     */
    chainID: string
  }
  export interface ClientGetChainIdParams {}
}

export enum Identifier {
  ClientConnectWallet = 'client.connect_wallet',
  ClientDisconnectWallet = 'client.disconnect_wallet',
  ClientGetPermissions = 'client.get_permissions',
  ClientRequestPermissions = 'client.request_permissions',
  ClientListKeys = 'client.list_keys',
  ClientSignTransaction = 'client.sign_transaction',
  ClientSendTransaction = 'client.send_transaction',
  ClientGetChainId = 'client.get_chain_id',
}

type Props = {
  hostname: string
  origin?: string
  token?: string
}

type Options = {
  id?: string
}

async function handleResponse<T>(res: Response) {
  if (!res.ok) {
    throw new Error(res.statusText)
  }
  const { jsonrpc, ...json } = await res.json()

  return json as Promise<{
    result: T
    id: string
  }>
}

export class WalletClient {
  private origin: string
  private hostname: string
  private token?: string

  constructor({ hostname, origin, token }: Props) {
    this.origin = origin || window.location.origin
    this.hostname = hostname
    this.token = token
  }

  /**
   * Initiates a connection between a wallet and a third-party application.
   */

  // tslint:disable-next-line:max-line-length
  public ClientConnectWallet = async (
    params: WalletModel.ClientConnectWalletParams = {},
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientConnectWallet,
        params: params,
      }),
    }).then((r) => handleResponse<WalletModel.ClientConnectWalletResult>(r))
  }

  /**
   * Returns the chain ID of the network in use.
   */

  // tslint:disable-next-line:max-line-length
  public ClientGetChainId = async (
    params: WalletModel.ClientGetChainIdParams = {},
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientGetChainId,
        params: params,
      }),
    }).then((r) => handleResponse<WalletModel.ClientGetChainIdResult>(r))
  }

  /**
   * Ends the connection between the third-party application and the wallet.
   */

  // tslint:disable-next-line:max-line-length
  public ClientDisconnectWallet = async (
    params: Omit<WalletModel.ClientDisconnectWalletParams, 'token'>,
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientDisconnectWallet,
        params: {
          ...params,
          token: this.token,
        },
      }),
    }).then((r) => handleResponse<WalletModel.ClientDisconnectWalletResult>(r))
  }

  /**
   * Returns the permissions set on the wallet for the third-party application.
   */

  // tslint:disable-next-line:max-line-length
  public ClientGetPermissions = async (
    params: Omit<WalletModel.ClientGetPermissionsParams, 'token'>,
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientGetPermissions,
        params: {
          ...params,
          token: this.token,
        },
      }),
    }).then((r) => handleResponse<WalletModel.ClientGetPermissionsResult>(r))
  }

  /**
   * Requests permissions update for the third-party application.
   */

  // tslint:disable-next-line:max-line-length
  public ClientRequestPermissions = async (
    params: Omit<WalletModel.ClientRequestPermissionsParams, 'token'>,
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientRequestPermissions,
        params: {
          ...params,
          token: this.token,
        },
      }),
    }).then((r) =>
      handleResponse<WalletModel.ClientRequestPermissionsResult>(r)
    )
  }

  /**
   * Returns the keys the user has allowed the third-party application to have access to.
   */

  // tslint:disable-next-line:max-line-length
  public ClientListKeys = async (
    params: Omit<WalletModel.ClientListKeysParams, 'token'>,
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientListKeys,
        params: {
          ...params,
          token: this.token,
        },
      }),
    }).then((r) => handleResponse<WalletModel.ClientListKeysResult>(r))
  }

  /**
   * Sign a transaction without sending it.
   */

  // tslint:disable-next-line:max-line-length
  public ClientSignTransaction = async (
    params: Omit<WalletModel.ClientSignTransactionParams, 'token'>,
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientSignTransaction,
        params: {
          ...params,
          token: this.token,
        },
      }),
    }).then((r) => handleResponse<WalletModel.ClientSignTransactionResult>(r))
  }

  /**
   * Send a transaction to the network.
   */

  // tslint:disable-next-line:max-line-length
  public ClientSendTransaction = async (
    params: Omit<WalletModel.ClientSendTransactionParams, 'token'>,
    options?: Options
  ) => {
    return fetch(`${this.hostname}/api/v2/requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Origin: this.origin,
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: options?.id || nanoid(),
        method: Identifier.ClientSendTransaction,
        params: {
          ...params,
          token: this.token,
        },
      }),
    }).then((r) => handleResponse<WalletModel.ClientSendTransactionResult>(r))
  }

  /**
   * Returns a list of supported methods
   */
  public ListMethods = async () => {
    return fetch(`${this.hostname}/api/v2/methods`).then((r) =>
      handleResponse<{
        registeredMethods: string[]
      }>(r)
    )
  }
}
